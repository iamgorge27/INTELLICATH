#include <HX711.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <EEPROM.h>

// HX711 pins
#define DT 4
#define SCK 16
HX711 scale;

// WiFi credentials
const char* ssid = "Pldt";  // Replace with your Wi-Fi SSID
const char* password = "Ladoysot567890!";  // Replace with your Wi-Fi password
const char* serverURL = "http://192.168.1.6:5001/predict-post";  // Replace with your Flask server IP and port

// Calibration factor for the load cell
float calibration_factor = 480; // Adjust based on your calibration
const int max_catheter_bag_volume = 1000; // Maximum capacity of the catheter bag in ml

// Variables for tracking data
float catheter_bag_volume = 0;
float urine_output = 0; // This is the value that will reset every hour
float starting_catheter_bag_volume = 0; // This tracks the volume at the start of the hour
float remaining_volume = 0;
unsigned long last_update_time = 0;
unsigned long hour_interval = 3600000; // 1 hour in milliseconds (3600000ms)

// Variables for data persistence
int eeprom_start_address = 0;

void setup() {
  Serial.begin(9600);

  // Initialize load cell
  Serial.println("Initializing load cell...");
  scale.begin(DT, SCK);
  scale.set_scale(calibration_factor); // Apply your calibration factor
  scale.tare(); // Reset the scale to 0
  Serial.println("Load cell initialized.");

  // Initialize EEPROM
  EEPROM.begin(512);
  catheter_bag_volume = readEEPROM();  // Retrieve the last known value from EEPROM
  Serial.println("Last catheter bag volume from EEPROM: " + String(catheter_bag_volume));

  // Connect to WiFi
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi...");
  }
  Serial.println("Connected to WiFi");
}

void loop() {
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("WiFi is connected.");

    // Read weight from load cell
    float current_bag_volume = scale.get_units(10); // Average of 10 readings
    if (current_bag_volume < 0) current_bag_volume = 0; // Ensure no negative weight
    Serial.println("Current catheter bag volume: " + String(current_bag_volume));

    // Update the catheter bag volume in real-time
    catheter_bag_volume = current_bag_volume;

    // Calculate the remaining catheter bag volume
    remaining_volume = max_catheter_bag_volume - catheter_bag_volume;

    // Calculate the real-time urine output for the current hour
    if (millis() - last_update_time <= hour_interval) {
      urine_output = catheter_bag_volume - starting_catheter_bag_volume; // Calculate the urine output for the hour
    }

    // Calculate urine flow rate using simple formula
    float urine_flow_rate = urine_output / 60.0; // Urine output per minute

    // Send real-time data to Flask server
    sendDataToServer(urine_output, urine_flow_rate, catheter_bag_volume, remaining_volume);

    // Check if one hour has passed
    if (millis() - last_update_time >= hour_interval) {
      // Reset urine output every hour
      urine_output = 0;  // Reset the urine output
      starting_catheter_bag_volume = catheter_bag_volume; // Set the current volume as the starting point for the next hour
      last_update_time = millis(); // Reset the hourly timer
    }

  } else {
    Serial.println("WiFi Disconnected. Reconnecting...");
    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED) {
      delay(1000);
    }
    Serial.println("Reconnected to WiFi");
  }

  delay(1000); // Delay to control reading frequency
}

void sendDataToServer(float urine_output, float urine_flow_rate, float catheter_bag_volume, float remaining_volume) {
  // Create JSON payload
  String jsonPayload = "{";
  jsonPayload += "\"urine_output\":" + String(urine_output, 2) + ",";
  jsonPayload += "\"urine_flow_rate\":" + String(urine_flow_rate, 2) + ",";
  jsonPayload += "\"catheter_bag_volume\":" + String(catheter_bag_volume, 2) + ",";
  jsonPayload += "\"remaining_volume\":" + String(remaining_volume, 2);
  jsonPayload += "}";

  // Print the payload for debugging
  Serial.println("Sending Data: " + jsonPayload);

  // Send data to the Flask backend
  HTTPClient http;
  http.begin(serverURL);
  http.addHeader("Content-Type", "application/json");

  int httpResponseCode = http.POST(jsonPayload);
  if (httpResponseCode > 0) {
    Serial.println("HTTP Response code: " + String(httpResponseCode));
    String response = http.getString();
    Serial.println("Response: " + response);
  } else {
    Serial.println("Error sending data: " + String(httpResponseCode));
  }

  http.end(); // End the HTTP connection
}

void saveToEEPROM(float value) {
  int intValue = (int)(value * 100); // Convert to integer for storage (2 decimal places)
  EEPROM.write(eeprom_start_address, (int)(intValue >> 8));  // Save the higher byte
  EEPROM.write(eeprom_start_address + 1, (int)(intValue & 0xFF));  // Save the lower byte
  EEPROM.commit();
}

float readEEPROM() {
  int highByte = EEPROM.read(eeprom_start_address);
  int lowByte = EEPROM.read(eeprom_start_address + 1);
  int intValue = (highByte << 8) + lowByte;
  return intValue / 100.0; // Convert back to float with 2 decimal places
}
