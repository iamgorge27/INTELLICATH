import ssl
import math
import pickle
import pymysql
import numpy as np
from flask import Flask, request, jsonify, render_template
from flask_cors import CORS
from sklearn.preprocessing import PolynomialFeatures, StandardScaler
from datetime import datetime

app = Flask(__name__)
CORS(app)

# ✅ Load ML Model & Preprocessing Tools
model = pickle.load(open("models/model_1.pkl", "rb"))
poly = pickle.load(open("models/polynomial_features.pkl", "rb"))
scaler = pickle.load(open("models/scaler.pkl", "rb"))

# ✅ MySQL Database Configuration
DB_CONFIG = {
    "host": "localhost",
    "user": "root",
    "password": "",
    "database": "intellicath",
    "cursorclass": pymysql.cursors.DictCursor
}

def get_db_connection():
    """Establish a MySQL database connection."""
    try:
        return pymysql.connect(**DB_CONFIG)
    except pymysql.MySQLError as e:
        print(f"[ERROR] Database Connection Failed: {e}")
        return None

latest_data = {}
previous_sent_data = {}  # ✅ Stores the last sent data to filter out noise
has_reached_800ml = False  # ✅ Flag to track when the catheter bag first reaches 800ml

@app.route("/")
def index():
    return render_template("index.html")

@app.route("/predict-post", methods=["POST"])
def predict():
    """Receives data from ESP32 via HTTP POST, processes it, and stores predictions."""
    global latest_data, has_reached_800ml
    data = request.get_json()

    if not data:
        return jsonify({"error": "No data received"}), 400

    try:
        urine_output = data.get("urine_output")
        urine_flow_rate = data.get("urine_flow_rate")
        catheter_bag_volume = data.get("catheter_bag_volume")
        remaining_volume = data.get("remaining_volume")

        # ✅ Validate Input Data
        if None in [urine_output, urine_flow_rate, catheter_bag_volume, remaining_volume]:
            return jsonify({"error": "Incomplete data provided"}), 400

        # ✅ Reset flag if bag is emptied (Catheter Bag Reaches 0 ml)
        if catheter_bag_volume == 0:
            has_reached_800ml = False  # ✅ Reset so actual_time can be logged again

        # ✅ Detect when volume reaches 800ml and store actual_time
        actual_time = None
        if catheter_bag_volume >= 800 and not has_reached_800ml:
            actual_time = datetime.now().strftime("%H:%M %p")  # ✅ Ensure proper datetime format
            has_reached_800ml = True  # ✅ Prevent duplicate timestamps

        # ✅ Preprocessing: Scale Data for Model
        features = np.array([[urine_output, urine_flow_rate, catheter_bag_volume, remaining_volume]])
        features_scaled = scaler.transform(poly.transform(features))

        # ✅ Make Prediction
        predicted_time_minutes = model.predict(features_scaled)[0]
        hours = math.floor(predicted_time_minutes)
        minutes = round((predicted_time_minutes - hours) * 60)
        if hours >= 24:
            hours = 0
        predicted_time = f"{int(hours):02} hours and {int(minutes):02} minutes"

        # ✅ Store Latest Prediction
        latest_data = {
            "urine_output": urine_output,
            "urine_flow_rate": urine_flow_rate,
            "catheter_bag_volume": catheter_bag_volume,
            "remaining_volume": remaining_volume,
            "predicted_time": predicted_time,
            "actual_time": actual_time  # ✅ Save actual_time when catheter bag reaches 800ml
        }

        # ✅ Store Data in MySQL only if values changed significantly
        save_data_to_db(latest_data)

        return jsonify(latest_data)

    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route("/predict-get", methods=["GET"])
def get_latest_data():
    """Returns the latest prediction only if it has significant changes (more than 2ml difference)."""
    global latest_data, previous_sent_data

    if not latest_data:
        return jsonify({"error": "No data available yet"}), 404

    # ✅ Check if the new data is significantly different from the last sent data
    if previous_sent_data:
        if abs(previous_sent_data["urine_output"] - latest_data["urine_output"]) <= 2 and \
           abs(previous_sent_data["urine_flow_rate"] - latest_data["urine_flow_rate"]) <= 0.1 and \
           abs(previous_sent_data["catheter_bag_volume"] - latest_data["catheter_bag_volume"]) <= 2:
            print("[INFO] No significant update. Returning last sent data.")
            return jsonify(previous_sent_data)  # ✅ Return previous values if no major change

    # ✅ Update stored data when there is a significant change
    previous_sent_data = latest_data.copy()

    return jsonify(latest_data)

def save_data_to_db(data):
    """Saves the latest data to MySQL if there is a change in values greater than 2ml."""
    try:
        connection = get_db_connection()
        if connection is None:
            return

        with connection.cursor() as cursor:
            # ✅ Check if Data Has Changed By More Than 2ml Before Inserting
            last_query = "SELECT * FROM intellicath_data ORDER BY id DESC LIMIT 1"
            cursor.execute(last_query)
            last_entry = cursor.fetchone()

            if last_entry:
                if abs(last_entry["urine_output"] - data["urine_output"]) <= 2 and \
                   abs(last_entry["urine_flow_rate"] - data["urine_flow_rate"]) <= 0.1 and \
                   abs(last_entry["catheter_bag_volume"] - data["catheter_bag_volume"]) <= 2:
                    print("[INFO] No significant change in data. Skipping insert.")
                    return

            sql = """
            INSERT INTO intellicath_data (urine_output, urine_flow_rate, catheter_bag_volume, remaining_volume, predicted_time, actual_time)
            VALUES (%s, %s, %s, %s, %s, %s)
            """
            cursor.execute(sql, (
                data["urine_output"], 
                data["urine_flow_rate"], 
                data["catheter_bag_volume"], 
                data["remaining_volume"], 
                data["predicted_time"],
                data["actual_time"]  # ✅ Save actual_time in MySQL
            ))
            connection.commit()
            print("[✅] Data inserted into database successfully.")

        connection.close()

    except pymysql.MySQLError as e:
        print(f"[ERROR] MySQL Insert Failed: {e}")

if __name__ == "__main__":
    # ✅ Enable SSL/TLS
    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
    context.load_cert_chain(certfile="localhost.pem", keyfile="localhost-key.pem")

    # ✅ Run Flask App with HTTPS
    app.run(debug=True, host="0.0.0.0", port=5001, ssl_context=context)
