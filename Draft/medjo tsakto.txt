#include <HX711.h>
#include <WiFi.h>
#include <HTTPClient.h>

// HX711 pins
#define DT 4
#define SCK 16
HX711 scale;

// WiFi credentials
const char* ssid = "Pldt";  // Replace with your Wi-Fi SSID
const char* password = "Ladoysot567890!";  // Replace with your Wi-Fi password
const char* serverURL = "http://192.168.1.6:5001/predict-post";  // Replace with your Flask server IP and port

// Calibration factor for the load cell
float calibration_factor = 480; // Adjust based on your calibration
const int max_catheter_bag_volume = 1000; // Maximum capacity of the catheter bag in ml

// Variables to track urine output over an hour
float cumulative_urine_output = 0;
unsigned long start_time = 0;
const unsigned long hour_interval = 10000; // 1 hour in milliseconds

void setup() {
  Serial.begin(9600);

  // Initialize load cell
  Serial.println("Initializing load cell...");
  scale.begin(DT, SCK);
  scale.set_scale(calibration_factor); // Apply your calibration factor
  scale.tare(); // Reset the scale to 0
  Serial.println("Load cell initialized.");

  // Connect to WiFi
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi...");
  }
  Serial.println("Connected to WiFi");

  // Initialize timing
  start_time = millis();
}


void loop() {
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("WiFi is connected.");

    // Read weight from load cell
    float catheter_bag_volume = scale.get_units(10); // Average of 10 readings
    Serial.println("Load cell reading: " + String(catheter_bag_volume));

    if (catheter_bag_volume < 0) catheter_bag_volume = 0; // Ensure no negative weight

    // Calculate remaining volume
    float remaining_volume = max_catheter_bag_volume - catheter_bag_volume;
    if (remaining_volume < 0) remaining_volume = 0; // Ensure no negative volume
    Serial.println("Remaining volume: " + String(remaining_volume));

    // Accumulate urine output over an hour
    cumulative_urine_output += catheter_bag_volume;
    Serial.println("Cumulative urine output: " + String(cumulative_urine_output));

    // Check if an hour has passed
    if (millis() - start_time >= hour_interval) {
      Serial.println("One hour passed. Preparing to send data...");

      // Calculate hourly urine output
      float urine_output = cumulative_urine_output;
      cumulative_urine_output = 0; // Reset for the next hour
      start_time = millis(); // Reset the timer

      // Calculate urine flow rate (average per minute)
      float urine_flow_rate = (urine_output / 60.0); // Assuming flow rate in ml/min

      // Create JSON payload
      String jsonPayload = "{";
      jsonPayload += "\"urine_output\":" + String(urine_output, 2) + ",";
      jsonPayload += "\"urine_flow_rate\":" + String(urine_flow_rate, 2) + ",";
      jsonPayload += "\"catheter_bag_volume\":" + String(catheter_bag_volume, 2) + ",";
      jsonPayload += "\"remaining_volume\":" + String(remaining_volume, 2);
      jsonPayload += "}";

      // Print the payload for debugging
      Serial.println("Sending Data: " + jsonPayload);

      // Send data to the Flask backend
      HTTPClient http;
      http.begin(serverURL);
      http.addHeader("Content-Type", "application/json");

      int httpResponseCode = http.POST(jsonPayload);
      if (httpResponseCode > 0) {
        Serial.println("HTTP Response code: " + String(httpResponseCode));
        String response = http.getString();
        Serial.println("Response: " + response);
      } else {
        Serial.println("Error sending data: " + String(httpResponseCode));
      }

      http.end(); // End the HTTP connection
    }
  } else {
    Serial.println("WiFi Disconnected. Reconnecting...");
    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED) {
      delay(1000);
    }
    Serial.println("Reconnected to WiFi");
  }

  delay(5000); // Read data every 5 seconds
}
